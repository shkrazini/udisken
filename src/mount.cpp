// UDISKEN: A small Linux automounter.
//
// Copyright (C) 2025 Sofian-Hedi Krazini
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// Contains the (auto)mounting logic itself.

#include "mount.hpp"

#include "udisks.hpp"
#include "utilities.hpp"

#include <sdbus-c++/Error.h>
#include <sdbus-c++/IConnection.h>
#include <sdbus-c++/ProxyInterfaces.h>
#include <sdbus-c++/Types.h>
#include <spdlog/spdlog.h>
#include <udisks-sdbus-c++/udisks_errors.hpp>

#include <cstdlib>
#include <format>
#include <map>
#include <string>
#include <string_view>
#include <vector>

namespace mount {

// Seemingly no methods generated by sdbus-c++ are marked
// const... Can't mark this const.
auto GetMountPoints(interfaces::UdisksFilesystem& fs) -> MountPoints {
  return utils::ConvertArrayArrayByte(fs.MountPoints());
}

void PrintMountPoints(const MountPoints& mnt_points) {
  spdlog::debug("Current mount points:");
  for (const auto& current_mnt_points : mnt_points) {
    spdlog::debug("- {}", current_mnt_points);
  }
}

namespace {

auto Mount(interfaces::UdisksFilesystem& fs) -> std::optional<std::string> {
  try {
    auto mnt_point = fs.Mount({});

    PrintMountPoints(GetMountPoints(fs));

    return mnt_point;
  } catch (const sdbus::Error& e) {
    if (e.getName() ==
        udisks_api::ErrorName(
            udisks_api::UdisksErrors::kUdisksErrorAlreadyMounted)) {
      spdlog::warn(
          "{} is already mounted but UDisks initially returned no mount paths;",
          fs.getProxy().getObjectPath().c_str());
      PrintMountPoints(GetMountPoints(fs));

      return std::nullopt;
    }

    spdlog::error("Failed to automount: {}", e.what());

    throw;
  }
}

void PrintNotAutomounting(const objects::BlockDevice& blk_device,
                          std::string_view reason) {
  spdlog::debug("Not automounting {}: {}", blk_device.ObjectPath().c_str(),
                reason);
}

}  // namespace

using namespace std::chrono_literals;

namespace {

auto OpenPathWithDefaultApp(const std::string& str) -> int {
  return std::system(std::format("xdg-open file://{}", str).c_str());
}

auto SystemCommandFailed(int stat_val) -> bool {
  return !WIFEXITED(stat_val) || WEXITSTATUS(stat_val) != 0;
}

}  // namespace

// TODO(blackma9ick): read from fstab, etc., for any additional mount points
// that UDisks may not know about, and mount to them.
auto TryAutomount(objects::BlockDevice& blk_device)
    -> std::optional<std::string> {
  interfaces::UdisksBlock& blk{blk_device.Block()};

  if (!blk.HintAuto()) {
    PrintNotAutomounting(blk_device, "automount hint was false");

    return std::nullopt;
  }

  // Could there even not be a filesystem if HintAuto was false?
  if (!blk_device.HasFilesystem()) {
    PrintNotAutomounting(blk_device, "no filesystem found");

    return std::nullopt;
  }

  // If mount points already exist, no need to automount it.
  if (!blk_device.Filesystem().MountPoints().empty()) {
    PrintNotAutomounting(blk_device, "already mounted");

    return std::nullopt;
  }

  std::optional<std::string> mnt_point{Mount(blk_device.Filesystem())};
  if (mnt_point) {
    spdlog::info("Automounted {}", *mnt_point);

    std::string blk_name{};
    if (!blk.HintName().empty()) {
      blk_name = blk.HintName();
    } else if (!blk.IdLabel().empty()) {
      blk_name = blk.IdLabel();
    } else {
      blk_name = "USB drive";
    }  // TODO(blackma9ick): also lookup UDisks2.Drive.Model
       // TODO(blackma9ick): To do that, consider storing the interfaces
       // somewhere and access them (start by reverting 25961a20e7d2).
    std::string blk_icon_name{blk.HintIconName().empty()
                                  ? "drive-removable-media"
                                  : blk.HintIconName()};

    const std::string action_open_fm{"system-file-manager"};
    const std::string action_open_fm_text{"Open in File Manager"};

    notify::Notification notif{
        .summary{"Mounted drive"},
        .body{std::format("{} at {}", blk_name, *mnt_point)},
        .app_icon{blk_icon_name},
        // FIXME(blackma9ick): on KDE Plasma 6.4.4, notifications close/crash
        // instantly if actions are given. Almost certainly a Plasma bug, and
        // even it were unsupported capabilities, it should ignore them, and not
        // crash and burn.
        .actions{action_open_fm, action_open_fm_text},
        .hints{{{"action_icons", sdbus::Variant{true}},
                {"category", sdbus::Variant{"device.added"}},
                {"sound_name", sdbus::Variant{"device-added-media"}}}}};
    notify::Notify(notif, [&](std::uint32_t id, std::string action_key) {
      if (action_key == action_open_fm) {
        if (int command_value{OpenPathWithDefaultApp(*mnt_point)};
            SystemCommandFailed(command_value)) {
          spdlog::warn(
              "xdg-open might have failed; check if xdg-utils is installed");
        }

        notify::CloseNotification(id);
      }
    });
  }

  return mnt_point;
}

}  // namespace mount
