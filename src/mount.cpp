// UDISKEN: A small Linux automounter.
//
// SPDX-FileCopyrightText: 2025 Sofian-Hedi Krazini <blackma9ick@proton.me>
// SPDX-License-Identifier: GPL-3.0-or-later
//
// Copyright (C) 2025 Sofian-Hedi Krazini
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
//
// You should have received a copy of the GNU General Public License along with
// this program.  If not, see <https://www.gnu.org/licenses/>.

/// Contains the (auto)mounting logic itself.

#include "mount.hpp"

#include "notify.hpp"
#include "options.hpp"
#include "udisks.hpp"

#include <sdbus-c++/Error.h>
#include <sdbus-c++/IConnection.h>
#include <sdbus-c++/ProxyInterfaces.h>
#include <sdbus-c++/Types.h>
#include <spdlog/spdlog.h>
#include <udisks-sdbus-cpp/udisks_errors.hpp>

#include <cstdint>
#include <cstdlib>
#include <format>
#include <map>
#include <memory>
#include <optional>
#include <ranges>
#include <string>
#include <string_view>
#include <vector>

namespace mount {

namespace {

/// Converts an array of array of bytes (D-Bus equivalent type: a{a{y}})
/// to a vector of strings.
///
/// @param aay The array of array of bytes.
auto ConvertArrayArrayByte(const std::vector<std::vector<std::uint8_t>>& aay)
    -> std::vector<std::string> {
  return aay | std::views::transform([](const auto& vec) {
           return std::string{std::from_range, vec};
         }) |
         std::ranges::to<std::vector<std::string>>();
}
// TEST: convert sample data.

}  // namespace

// Seemingly no methods generated by sdbus-c++ are marked
// const... Can't mark this const.
MountPoints GetMountPoints(udisks_sd::proxy_wrappers::UdisksFilesystem& fs) {
  return ConvertArrayArrayByte(fs.MountPoints());
}

void DebugMountPoints(const MountPoints& mnt_points) {
  for (const auto& mnt_point : mnt_points) {
    spdlog::debug("- {}", mnt_point);
  }
}

namespace {

int OpenPathWithDefaultApp(const std::string& str) {
  return std::system(std::format("xdg-open file://{}", str).c_str());
}

bool SystemCommandFailed(int stat_val) {
  return !WIFEXITED(stat_val) || WEXITSTATUS(stat_val) != 0;
}

void PrintNotAutomounting(const objects::BlockDevice& blk_device,
                          std::string_view reason) {
  spdlog::debug("Not automounting {}: {}", blk_device.ObjectPath().c_str(),
                reason);
}

bool NotifyMounted(udisks_sd::proxy_wrappers::UdisksBlock& blk,
                   const std::string& mnt_point) {
  std::string blk_name{};
  if (!blk.HintName().empty()) {
    blk_name = blk.HintName();
  } else if (!blk.IdLabel().empty()) {
    blk_name = blk.IdLabel();
  } else {
    blk_name = "Drive";
  }  // TODO: also lookup UDisks2.Drive.Model
     // TODO: To do that, consider storing the interfaces
     // somewhere and access them (start by reverting e5d18f78b47e).
  std::string blk_icon_name{blk.HintIconName().empty() ? "drive-removable-media"
                                                       : blk.HintIconName()};

  const std::string action_open_fm{"system-file-manager"};
  const std::string action_open_fm_text{"Open in File Manager"};

  const notify::Notification notif{
      .summary{"Mounted drive"},
      .body{std::format("{} at {}", blk_name, mnt_point)},
      .app_icon{blk_icon_name},
      // FIXME: on KDE Plasma 6.4.4, notifications close/crash
      // instantly if actions are given. Almost certainly a Plasma bug, and
      // even it were unsupported capabilities, it should ignore them, and not
      // crash and burn.
      .actions{action_open_fm, action_open_fm_text},
      .hints{{{"action_icons", sdbus::Variant{true}},
              {"category", sdbus::Variant{"device.added"}},
              {"sound_name", sdbus::Variant{"device-added-media"}}}}};

  std::shared_ptr<sdbus::IProxy> notify_proxy =
      sdbus::createProxy(notify::kNotifServiceName, notify::kNotifObjectPath);

  auto open_app_fn{[=](std::uint32_t id, std::string action_key) {
    if (action_key == action_open_fm) {
      if (int command_value{OpenPathWithDefaultApp(mnt_point)};
          SystemCommandFailed(command_value)) {
        spdlog::warn(
            "xdg-open might have failed; check if xdg-utils is installed");
      }

      notify::CloseNotification(*notify_proxy, id);
    }
  }};

  return notify::Notify(*notify_proxy, notif, open_app_fn);
}

auto Mount(udisks_sd::proxy_wrappers::UdisksFilesystem& fs)
    -> std::optional<std::string> {
  try {
    auto mnt_point{fs.Mount({})};

    spdlog::debug("Current mount points:");
    DebugMountPoints(GetMountPoints(fs));

    return mnt_point;
  } catch (const sdbus::Error& e) {
    if (e.getName() ==
        udisks_sd::ErrorName(
            udisks_sd::UdisksErrors::kUdisksErrorAlreadyMounted)) {
      spdlog::warn(
          "{} is already mounted but UDisks initially returned no mount paths;",
          fs.getProxy().getObjectPath().c_str());
      spdlog::debug("Current mount points after trying to mount:");
      DebugMountPoints(GetMountPoints(fs));
    }

    spdlog::error("Failed to automount: {}", e.what());

    return std::nullopt;
  }
}

}  // namespace

// TODO: read from fstab, etc., for any additional mount points
// that UDisks may not know about, and mount to them.
auto TryAutomount(objects::BlockDevice& blk_device)
    -> std::optional<std::string> {
  udisks_sd::proxy_wrappers::UdisksBlock& blk{blk_device.Block()};

  if (!blk.HintAuto()) {
    PrintNotAutomounting(blk_device, "automount hint was false");

    return std::nullopt;
  }
  // Could there even not be a filesystem if HintAuto was false?
  if (!blk_device.HasFilesystem()) {
    PrintNotAutomounting(blk_device, "no filesystem found");

    return std::nullopt;
  }
  // If mount points already exist, no need to automount it.
  if (!GetMountPoints(blk_device.Filesystem()).empty()) {
    PrintNotAutomounting(blk_device, "already mounted");

    return std::nullopt;
  }

  auto mnt_point{Mount(blk_device.Filesystem())};
  if (!mnt_point) {
    return std::nullopt;
  }

  spdlog::info("Automounted {}", *mnt_point);
  if (options::NotifyEnabled()) {
    NotifyMounted(blk, *mnt_point);
  }

  return mnt_point;
}

}  // namespace mount
